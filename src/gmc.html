<!DOCTYPE html>
<html>
<!--
MIT License

Copyright (c) 2024 Adam McKenney

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-->

<head>
	<title> G &amp; M Checker </title>
	<style>
	/* Style to make each div 33% of the screen width */
	.column {
		width: 33.33%;
		float: left;
		box-sizing: border-box;
		padding: 15px; /* Add padding for better appearance */
		box-sizing: border-box;
	}
	.center-heading {
		text-align: center;
	}
	.programming {
		font-family: "Courier New", Courier, monospace;
	}
	mark {
		background-color: red;
		color: black;
	}
	</style>
</head>
<body style="background-color:darkgray; color:white;">
	<div class="column">
		<h1 class="center-heading"> User Input </h1>
		<textarea id="user_input" rows="25" cols="50">Paste Your GCode Here...</textarea><br>
	 	<button onclick="check_input();">Check GCode</button>
	</div>

	<div class="column">
		<h1 class="center-heading"> Detailed Look </h1>
		<p id="line_output" class="programming"><br></p>
	</div>

	<div class="column">
		<h1 class="center-heading"> Output </h1>
		<p id="output"><br></p>
		<p id="error_count"><br></p>
	</div>
	<script>

//Global vars
var warnings = 0;
var errors = 0;

function write_to_output(data){
	document.getElementById("output").innerHTML += data + "</br></br>";
}

function w2l(data){
	document.getElementById("line_output").innerHTML += data + "</br>";
}

function refresh_error_count(){
	document.getElementById("error_count").innerHTML = "Error(s): " + errors + " | Warning(s): " + warnings + "</br>";
}

function output_program(data, error_list){
	//writes to line_output in html, highlights lines that have issues
	let line_number = 0;
	for(let i = 0; i < data.length; i++){
		if((i+1) < 10)
			line_number = "|  " + (i+1) + "| ";
		else if((i+1) < 100)
			line_number = "| " + (i+1) + "| ";
		else
			line_number = (i+1);
		if(error_list.includes(i))
			w2l("<mark>" + line_number + data[i] + "</mark>");
		else
			w2l(line_number + data[i]); 
	}
}

function reset_state(){
	document.getElementById("output").innerHTML = "</br>";
	document.getElementById("line_output").innerHTML = "</br>";
	warnings = 0;
	errors = 0;
	console.clear();
}

function log(ew, data){
//used to more easiy change where debug info goes
	if(ew == 'E'){
		write_to_output("Error: " + data);
		errors++;
	} else if(ew == 'W'){
		write_to_output("Warning: " + data);
		warnings++;
	} else
		console.log(data);
}

function handle_gcode(gcode, error_list, line_number, flags){
	switch (gcode){
		case "G00":
		case "G01":
		case "G02":
		case "G03":
			flags[gcode] = true;
			return;
	}
	if(gcode == "G90"){
		if(flags[gcode] == true){
			log('W', "Repeat G90 decleration, line " + (line_number+1));
		} else {
			flags[gcode] = true;
		}
	} else {
		throw new Error("Internal error. Unsupported GCode. If you are reading this, the programmer forgot to finish adding your gcode command");
	}
}

function handle_fcode(gcode, error_list, line_number, flags){
	if(gcode == "F10"){
		if(flags[gcode] == true)
			log('W', "Repeat F10 decleration, line " + (line_number+1));
		else
			flags[gcode] = true;
	} else {
		log('E', "Feed rate is not set to 10! This can break the cutting bit! Line " + (line_number+1));
		error_list.push(line_number);
	}
}

function handle_mcode(gcode, error_list, line_number, flags){
	// Before calling this function, the program should check if it is an aproved M code
	if(flags[gcode] == true)
		log('W', "Repeat " + gcode + " decleration, line " + (line_number+1));
	else
		flags[gcode] = true;
}

function handle_typos(gcode, error_list, line_number, typo_list){
	if(typo_list.includes(gcode)){
		log('E', "You used the letter 'o' instead of the number 0 (e.x. Go1 =/= G01), line " + (line_number+1));
	} else {
		log('E', "Unknown command '" + gcode + "', line " + (line_number+1));
	}
	error_list.push(line_number);
}

function check_gcode(gcode_list){
	
	//defaults
	const x_low_bounds = 0.0;
	const x_high_bounds = 4.0;
	const y_low_bounds = 0.0;
	const y_high_bounds = 4.0;
	const z_low_bounds = -0.250;
	const z_high_bounds = 1.0;
	const i_low_bounds = -4.0;
	const i_high_bounds = 4.0;
	const j_low_bounds = -4.0;
	const j_high_bounds = 4.0;
	const minimum_line_length = 25;
	const valid_gcode = ["G00", "G01", "G02", "G03", "G90"];
	const valid_mcode = ["M03", "M05"];
	const typo_list = ["GOO", "GO0", "G0O", "GO1", "GO2", "GO3", "G9O", "MO3", "MO5", "F1O"]; //note those are o's not 0's


	let error_list = [-1];
	

	let flags = {
		"G00": false,
		"G01": false,
		"G02": false,
		"G03": false,
		"G90": false,
		"F10": false,
		"M03": false,
		"M05": false,
		"Z"  : false //z change
	};

	//Old flags
	//flags
	let has_z_change = false;


	//Check first two lines for comments
	if(gcode_list[0][0] != '('){
		log('W', "Missing program title. Line 1");
	} else if(gcode_list[1][0] != '('){
		log('W', "Missing authors name. Line 2");
	}

	for(let i = 0; i < gcode_list.length; i++){
		let gcode_tokens = gcode_list[i].split(" ");
		console.log("gcode_list[" + i + "] '" + gcode_list[i] + "'");
		console.log("gcode_tokens '" + gcode_tokens + "'");

		// Check each token
		for(let j = 0; j < gcode_tokens.length; j++){
			console.log("Checking token '" + gcode_tokens[j] + "'");
			if(gcode_tokens[j][0] == '('){
				//HACK skips the rest of the line. TODO loop until other ) is found
				break;
			} else if(valid_gcode.includes(gcode_tokens[j])){
				handle_gcode(gcode_tokens[j], error_list, i, flags);
			} else if(gcode_tokens[j][0] == 'F'){
				handle_fcode(gcode_tokens[j], error_list, i, flags);
			} else if(valid_mcode.includes(gcode_tokens[j])){
				handle_mcode(gcode_tokens[j], error_list, i, flags);
			} else if(gcode_tokens[j][0] == 'X'){
				//check bounds
				let num = parseFloat(gcode_tokens[j].substring(1));
				if(num > x_high_bounds || num < x_low_bounds){
					log('E', "X is out of bounds (" + x_low_bounds + " through " + x_high_bounds + "), line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else if(isNaN(num)) {
					log('E', "Unrecognized command or missing cords, line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				}
			} else if(gcode_tokens[j][0] == 'Y'){
				//check bounds
				let num = parseFloat(gcode_tokens[j].substring(1));
				if(num > y_high_bounds || num < y_low_bounds){
					log('E', "Y is out of bounds (" + y_low_bounds + " through " + y_high_bounds + "), line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else if(isNaN(num)){
					log('E', "Unrecognized command or missing cords, line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				}
			} else if(gcode_tokens[j][0] == 'Z'){
				//check bounds
				let num = parseFloat(gcode_tokens[j].substring(1));
				if(num > z_high_bounds || num < z_low_bounds){
					log('E', "Z is out of bounds (" + z_low_bounds + " through " + z_high_bounds + "), line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else if(isNaN(num)){
					log('E', "Unrecognized command or missing cords, line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else {
					has_z_change = true;
				}
			} else if(gcode_tokens[j][0] == 'I'){
				//check bounds
				let num = parseFloat(gcode_tokens[j].substring(1));
				if(num > i_high_bounds || num < i_low_bounds){
					log('E', "I is out of bounds (" + i_low_bounds + " through " + i_high_bounds + "), line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else if(isNaN(num)){
					log('E', "Unrecognized command or missing cords, line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				}
			} else if(gcode_tokens[j][0] == 'J'){
				//check bounds
				let num = parseFloat(gcode_tokens[j].substring(1));
				if(num > j_high_bounds || num < j_low_bounds){
					log('E', "J is out of bounds (" + j_low_bounds + " through " + j_high_bounds + "), line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				} else if(isNaN(num)){
					log('E', "Unrecognized command or missing cords, line " + (i+1) + ", command " + (j+1));
					error_list.push(i);
				}
			} else {
				//check for typos, if not then error out for unknown command
				handle_typos(gcode_tokens[j], error_list, i, typo_list);
			}
		}
	}
	//Check for what we are missing
	// Errors
	if(flags["G90"] == false) log('E', "Missing G90");
	if(flags["F10"] == false) log('E', "Missing F10");
	if(flags["M03"] == false) log('E', "Missing M03");
	if(flags["M05"] == false) log('E', "Missing M05");
	if(flags["G01"] == false) log('E', "Missing G01 in your program!");
	if(has_z_change == false) log('E', "Missing Z change (e.x. G01 Z-0.25), your material will not be cut!");
	if(gcode_list[gcode_list.length-1].split(" ")[0] != "M05" && flags["M05"] == true)
		log('E', "M05 was used too early THIS CAN BREAK THE CUTTING BIT. M05 should be the last line");
	
	// Warnings
	if(flags["G00"] == false) log('W', "Missing G00");
	if(flags["G02"] == false & flags["G03"] == false) log('W', "Missing G02 or G03 (arcs)");
	if(gcode_list.length < minimum_line_length) log('W', "Does not meet minimum line length of " + minimum_line_length);

	// Writes out the program to show the user what they did wrong
	output_program(gcode_list, error_list);
}

function check_input(){
	//Program Start
	reset_state();
	let raw_gcode = document.getElementById('user_input').value;
	let raw_gcode_list = raw_gcode.toUpperCase().split("\n");
	check_gcode(raw_gcode_list);
	refresh_error_count();
}

	</script>
</body>
</html>
